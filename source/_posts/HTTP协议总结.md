---
title: HTTP协议总结
date: 2017-11-23 11:09:43
categories: 前端
tags: 前端
---

[脑图总结连接](http://naotu.baidu.com/file/e0bff2c766dea59043b2ba718d5e3bc1?token=6d2695175ad294d1)
# HTTP协议

## HTTP2

1. 多路复用

    * 允许同时通过单一的HTTP2链接发起多重请求

    * HTTP1.1中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞

    * HTTP2可以很容易的实现多流并行而不用依赖建立TCP链接。通信都在一个连上完成，这个连接可以承载任意数量的双向数据流。HTTP2通过让所有数据流共用个连接，可以更有效的使用TCP连接，让高带宽也能真正服务于HTTP的性能提升

    * 单连接多资源的方式，减少服务端的链接压力，内存占用更少，连接吞吐量更大
    * 由于TCP连接的减少而使用网络拥塞状况得以改善，同时慢启动时间的减少，使拥塞和丢包恢复速度更快

    * 可设置优先级

    * 重置连接表现更好

    * 可以取消某个stream的请求，不影响连接

2. 二进制分帧

    * 不改动HTTP1.x的语义方法状态码等的情况下，通过在应用层和传输层之间增加一个二进制分帧层

    * 在二进制分帧层中，HTTP2会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码

    * HTTP1.x的首部信息会被封装到HEADER frame，而相应的Request Body则封装到DATA frame里面

3. 首部压缩

    * HTTP1.x不支持首部压缩，为此SPDY和HTTP2应运而生，SPDY使用的是通用的DEFLATE算法，而HTTP2则使用了专门为首部压缩而设计的HPACK算法

    * header中由于cookie和user Agent很容易膨胀，而且每次都要重复发送

    * HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小

    * 高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟

4. 服务端推送

    * 是一种在客户端请求之前发送数据的机制

    * 在HTTP2中，服务器可以对客户端的一个请求发送多个响应

## HTTP1.0

1. 连接无法复用,导致的问题

    * 导致每次请求都经历三次握手和慢启动

    * 三次握手在高延迟的场景下影响比较明显慢启动则对文件类大请求影响较大

2. 解决方法

    * 在header里设置Connection:Keep-Alive

    * 时间可由服务器设置

    * HTTP1.1之后默认是keep-alive

3. head of line block(管线屏蔽)

    * 导致带宽无法被充分利用，以及后续健康请求被阻塞

    * 在第一个请求没有收到回复之前，后续从应用层发出的请求只能排队

4. HTTP1慢启动

    * 过去HTTP性能优化的关键并不在于高带宽，而是低延迟。TCP连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度

## SPDY

1. 多路复用

2. 请求优先级

3. header压缩

4. server推送

5. server暗示

## HTTP1.1

1. 可扩展，可以增加自定义头域

2. 增加了文件断点续传增加了range头域允许只请求资源
的某个部分

3. 缓存

    * 强制缓存

        **缓存有效时不与服务器交互**

        1. Expires1.0支持，返回到期时间，下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据

        2. Cache-Control 1.1支持

            * private：客户端可以缓存

            * publick：客户端和代理服务器都可以缓存

            * max-age=xxx：缓存的内容将在xxx秒后失效

            * no-cache：需要使用对比缓存来验证缓存数据

            * no-store:所有内容都不会缓存，强制缓存，对比缓存都不会触发

    * 对比缓存

        **不管缓存是否有效都要先与服务器交互**

        **生效时的状态码为304**

        1. Last-Modified:第一次请求时，服务器返回的资源最后
        修改时间，在response header中

        2. If-Modified-Since:再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间服务器收到后与请求资源的最后修改时间做对比，如果改动过返回内容，返回状态码200，若无变化则返回状态码304

        3. Etag(优先级高于Last-Modified)

            * 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识生成规则由服务器决定

        4. If-None-Match(优先级高于If-Modified-Since)

            * 再次请求时，浏览器通知服务器上次返回的资源唯一标识

4. 请求流水线处理，不用等待上一次请求结果返回，就可以发出下一次请求，但是服务器端必须按照接收到客户端的请求先后顺序返回响应结果

5. 增加host字段

6. 节约带宽，增加了一个100状态码，事先发送一个只带
头域的请求，如果服务器因为权限拒绝了请求那么就回
送响应401，如果服务器接收此请求就回送响应码10
0，客户端就可以发送带实体的完整请求了



